#include <stdio.h>
#include "alt_types.h"
#include "sys/alt_irq.h"
#include "altera_avalon_timer.h"
#include "altera_avalon_timer_regs.h"
#include "altera_avalon_pio_regs.h"
#include "altera_avalon_sysid_qsys.h"
#include "altera_avalon_sysid_qsys_regs.h"
#include <unistd.h>
#include "sys/alt_stdio.h"
#include "system.h"
#include "io.h"
#include "sys/alt_alarm.h"
#include "AD9102.h"
#include "AMC7891.h"
#include "i2c.h"
#include "timer.h"
#include "trprintf.h"
#include "TSEConfig.h"
#include "rx_ink_common.h"
#include "nios_def_head.h"
#include "version.h"
#include "uart.h"
#include "conditioner_bootloader.h"
#include "altera_avalon_uart_regs.h"
#include "adc_thermistor.h"
#include "cond_def_head.h"
#include "comm.h"
#include "tmp007.h"
#include "watchdog.h"
#include "head_eeprom.h"
#include "power.h"
#include "pres.h"

//Prototype

SNiosMemory *arm_ptr;
SNiosCfg	*pRX_Config;
SNiosStat	*pRX_Status;

typedef struct
{
	int 	timer;
	UINT32	alive;
	SCondErr_mcu	error;
} _SConditioner;

static _SConditioner _Cond[MAX_HEADS_BOARD];

//--- main_handle_cond_msg ---------------------------
static void _handle_cond_msg(int condNo)
{
	_Cond[condNo].timer = 3;
	if (_Cond[condNo].error.rebooted)
	{
		pRX_Status->cond[condNo].error.rebooted=TRUE;
	}
	else
	{
		if (pRX_Status->cond[condNo].alive < _Cond[condNo].alive && _Cond[condNo].alive<0x80000000)
			_Cond[condNo].error.rebooted = TRUE;
		_Cond[condNo].alive = pRX_Status->cond[condNo].alive;
	}

	/*
	if (condNo==3 && pRX_Status->cond[condNo].logCnt)
	{
		int i;
		for (i=0; i<pRX_Status->cond[condNo].logCnt; i++)
		{
			trprintf("%03d: %03d %03d\n", pRX_Status->cond[condNo].log[i].no, pRX_Status->cond[condNo].log[i].pressure, pRX_Status->cond[condNo].log[i].pump);
		}

	}
	*/

	/*
	trprintf("Cond[%d]: Version: %d.%d.%d.%d, ",
			condNo,
			(int)arm_ptr->stat.cond[condNo].version.major,
			(int)arm_ptr->stat.cond[condNo].version.minor,
			(int)arm_ptr->stat.cond[condNo].version.revision,
			(int)arm_ptr->stat.cond[condNo].version.build);
	trprintf("alive=%d, temp=%d, presin=%d, presout=%d, pump=%d, valve=%d\n",
			(int)pRX_Status->cond[condNo].alive,
			(int)pRX_Status->cond[condNo].temp,
			(int)pRX_Status->cond[condNo].pressure_in,
			(int)pRX_Status->cond[condNo].pressure_out,
			(int)pRX_Status->cond[condNo].pump,
			(int)pRX_Status->cond[condNo].info.valve);
	*/
}

//--- main_rebooting_cond ------------------------------
void main_rebooting_cond(void)
{
	int i;
	for (i=0; i<MAX_HEADS_BOARD; i++) _Cond[i].alive=0xFFFFFFFF;
}

//--- main_tick_1000ms ------------------------------
void main_tick_1000ms(void)
{
	int condNo;

	if (!bootloader_running())
	{
		for (condNo=0; condNo<MAX_HEADS_BOARD; condNo++)
		{
			if (pRX_Status->cond[condNo].info.connected)
			{
				if (--_Cond[condNo].timer<0)
				{
					pRX_Status->cond[condNo].info.connected = FALSE;
					pRX_Status->cond[condNo].error.connection_lost = TRUE;
				}
			}
		}

	}
}

//--- alt_avalon_sysid_qsys_test ------------------------------------------------
alt_32 alt_avalon_sysid_qsys_test(void)
{
  // Read the hardware-tag, aka value0, from the hardware. */
  alt_u32 hardware_id = IORD_ALTERA_AVALON_SYSID_QSYS_ID(SYSID_QSYS_BASE);

  /* Read the time-of-generation, aka value1, from the hardware register. */
  alt_u32 hardware_timestamp = IORD_ALTERA_AVALON_SYSID_QSYS_TIMESTAMP(SYSID_QSYS_BASE);

  /* Return 0 if the hardware and software appear to be in sync. */
  if ((SYSID_QSYS_TIMESTAMP == hardware_timestamp) && (SYSID_QSYS_ID == hardware_id))
  {
    return 0;
  }

  /*
  *  Return 1 if software appears to be older than hardware (that is,
  *  the value returned by the hardware is larger than that recorded by
  *  the generator function).
  *  If the hardware time happens to match the generator program's value
  *  (but the hardware tag, value0, doesn't match or 0 would have been
  *  returned above), return an arbitrary value, let's say -1.
  */
  return ((alt_32)(hardware_timestamp - SYSID_QSYS_TIMESTAMP)) > 0 ? 1 : -1;
}

//--- main ----------------------------------------------------
int main()
{
	int condNo;

//	tr_debug();

	watchdog_init();
//	watchdog_start_debug_mode();

	// Dual port ram initialisation
	arm_ptr	= (SNiosMemory *) DP_RAM_NIOS_ARM_BASE;
	pRX_Config = &arm_ptr->cfg;
	pRX_Status = &arm_ptr->stat;

	memset(_Cond, 0, sizeof(_Cond));
	memset(pRX_Config, 0, sizeof(*pRX_Config));
	memset(pRX_Status, 0, sizeof(*pRX_Status));
	// NIOS Version
	pRX_Status->version.major	= ver_major;
	pRX_Status->version.minor 	= ver_minor;
	pRX_Status->version.build 	= ver_build;
	pRX_Status->version.revision= ver_revision;

	if ( alt_avalon_sysid_qsys_test()) pRX_Status->error.fpga_incompatible = TRUE;
	// pRX_Status->info.sys_id_checked=1;

	IOWR_ALTERA_AVALON_PIO_DATA(PIO_NIOS_LED_BASE,0x03);				// Nios all LED's off
	IOWR_ALTERA_AVALON_PIO_DATA(PIO_RESET_DAC_BASE,0x0f);				// release reset for all DAC's

	// Analog monitor initialisation
	if(init_AMC7891()) pRX_Status->error.amc7891=1;

	// I2C initialisation
	IOWR_16DIRECT(AMC7891_0_BASE, AMC7891_DAC0_DATA, _3V3);	//Power for Levelshifter I2C and Flow Check Sensor
	init_I2C(I2C_MASTER_0_BASE);	// Head EEPROM (I2C Adr. 0x52/0x54/0x56/0x58), Flow Check Pressure (I2C Adr. 0x78)
	init_I2C(I2C_MASTER_1_BASE);	// MOSFET Temperature

	// IR Temp. Sensor TMP0007 initialisation
	tmp_init();

	power_init();

	// DAC AD9102 initialisation
	if(init_DAC(AVALON_SPI_AD9102_0_BASE)) pRX_Status->error.AD9102_0=TRUE;
	if(init_DAC(AVALON_SPI_AD9102_1_BASE)) pRX_Status->error.AD9102_1=TRUE;
	if(init_DAC(AVALON_SPI_AD9102_2_BASE)) pRX_Status->error.AD9102_2=TRUE;
	if(init_DAC(AVALON_SPI_AD9102_3_BASE)) pRX_Status->error.AD9102_3=TRUE;
	
	// set default values for conditioner boards
	IOWR_ALTERA_AVALON_PIO_DATA(COND_PIO_0_BASE, 0b0001); //reserve=0, oe_bootloader=0; boot_uc=0, reset=1	//disable oe_bootloader
	IOWR_ALTERA_AVALON_PIO_DATA(COND_PIO_1_BASE, 0b0001); //reserve=0, oe_bootloader=0; boot_uc=0, reset=1	//disable oe_bootloader
	IOWR_ALTERA_AVALON_PIO_DATA(COND_PIO_2_BASE, 0b0001); //reserve=0, oe_bootloader=0; boot_uc=0, reset=1	//disable oe_bootloader
	IOWR_ALTERA_AVALON_PIO_DATA(COND_PIO_3_BASE, 0b0001); //reserve=0, oe_bootloader=0; boot_uc=0, reset=1	//disable oe_bootloader

	pres_init();	// init Flow Check Pressure Sensor

	timer_init();

	uart_init();
	trprintf("MAIN STARTED\n");
	if(head_eeprom_read())
	{
		pRX_Status->error.head_eeprom_read=1;
		init_I2C(I2C_MASTER_0_BASE);	//reinitialise I2C, as there is no head Connected
	}

	// Event loop never exits
	pRX_Status->info.nios_ready=TRUE;
	while (1)
	{
		timer_main();
		UCHAR data;
		for (condNo=0; condNo<MAX_HEADS_BOARD; condNo++)
		{
			if (uart_read(condNo, &data))
			{
				if (comm_received(condNo, data))
				{
					int length;
					SConditionerStat_mcu data;
					if (comm_get_data(condNo, (UCHAR*)&data, sizeof(data), &length))
					{
						if (length==sizeof(pRX_Status->cond[condNo]))
						{
							memcpy(&pRX_Status->cond[condNo], &data, sizeof(pRX_Status->cond[condNo]));
							_handle_cond_msg(condNo);
						}
						else pRX_Status->cond[condNo].error.err04=TRUE;
					}
				}
			}
		}
	}//end while (1)
	return (0);
}// end int main()
