// ****************************************************************************
//
//	DIGITAL PRINTING - cond_comm.c
//
//	Downlaoding the conditioner
//
// ****************************************************************************
//
//	Copyright 2018 by Mouvent AG, Switzerland. All rights reserved.
//	Written by Marcel Galliekr
//
// ****************************************************************************
//
//	last version with NIOS-download: 18-DEZ-17, REV 4491
//
//--- includes ----------------------------------------------------------------

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <termios.h>
#include <time.h>
#include <unistd.h>

#include "comm.h"

#include "rx_common.h"
#include "rx_error.h"
#include "rx_term.h"
#include "rx_threads.h"
#include "rx_trace.h"

#include "crc_calc.h"
#include "nios.h"
#include "conditioner.h"
#include "cond_comm.h"


//--- structures -------------------

#pragma pack(1)

#define  FLASH_BLK_SIZE		512

typedef struct
{
	UCHAR   cmd;
	UINT32 addr;
} SFlashCmd;

typedef struct
{
	UCHAR data[FLASH_BLK_SIZE];
	UCHAR crc_high;
	UCHAR crc_low;
} SFlashData;
#pragma pack()

//--- prototypes -----------------------------------------------
static void *_uart_thread(void *ppar);
static void *_uart_load_thread(void *ppar);
static void *_uart_recv_thread(void *ppar);
static void  _uart_set_baud(int comm, int baud, int blksize);
static int	 _cond_receive(int comm, int condNo, int cnt);
static int   _program_exe(int comm, int condNo);
static int   _send_ram_kernel(int comm, int condNo);
static int   _send(int comm, int no, UCHAR *data, int len, UCHAR reply, int tio);
static int	 _read_block(int comm, int condNo, int tio, UCHAR *buf, int size);
static int   _read_user_flash(int comm, int condNo, SFlashData *data);
static int   _write_user_flash(int comm, int condNo, SFlashData *data);
static int   _erase_and_check(int comm, int condNo);
static int   _program_flash	(int comm, int condNo, UCHAR *buf, int size);


static	SVersion		_FileVersion;
static int				_COMM[MAX_HEADS_BOARD] = { 0 };
static EnDownloadState	_DnlState[MAX_HEADS_BOARD];
static int				_DnlError[MAX_HEADS_BOARD];
static int				_DnlProgress[MAX_HEADS_BOARD];
static int				_CondRunning;
static int				_CondStartup;
static int				_CondProgram;



static UCHAR _0x18[] = { 0x18 };
static UCHAR _0xe8[] = { 0xe8 };
static UCHAR ram_kernel_prepare []={0x00, 0x00, 0xe9, 0x03, 0x20, 0x20, 0x08, 0x00, 0x00, 0x34};
static UCHAR ram_kernel[]={0x00,0xF0,0x00,0xB8,0x00,0xE0,0x00,0x01,0x4F,0xF2,0x00,0x20,0xC2,0xF2,0x03,0x00,0x40,0xF2,0x00,0x01,0xC2,0xF2,0x04,0x01,0x4F,0xEA,0x01,0x0D,0x31,0x21,0x00,0xF0,0x95,0xFB,0x4E,0xF6,0x07,0x12,0xC2,0xF2,0x03,0x02,0x11,0x78,0x00,0x22,0x4A,0x40,0x72,0xB1,0x01,0x22,0x4A,0x40,0x72,0xB1,0x02,0x22,0x4A,0x40,0x72,0xB1,0x03,0x22,0x4A,0x40,0x72,0xB1,0x04,0x22,0x4A,0x40,0x72,0xB1,0x05,0x22,0x4A,0x40,0x72,0xB1,0x09,0x25,0x05,0x26,0x0C,0xE0,0x09,0x25,0x05,0x26,0x45,0xE0,0x09,0x25,0x02,0x26,0x42,0xE0,0x19,0x25,0x02,0x26,0x3F,0xE0,0x29,0x25,0x02,0x26,0x3C,0xE0,0x76,0xE0,0x40,0xF2,0x38,0x07,0xC4,0xF2,0x01,0x07,0x3D,0x70,0x40,0xF2,0x3C,0x07,0xC4,0xF2,0x01,0x07,0x3E,0x70,0x40,0xF2,0x34,0x07,0xC4,0xF2,0x01,0x07,0x17,0x25,0x3D,0x70,0x40,0xF2,0x00,0x07,0xC4,0xF2,0x01,0x07,0x10,0x25,0x3D,0x70,0x40,0xF2,0x04,0x07,0xC4,0xF2,0x01,0x07,0x97,0xF9,0x00,0x60,0x10,0x25,0x75,0x40,0x05,0xB1,0xF5,0xE7,0x40,0xF2,0x14,0x07,0xC4,0xF2,0x01,0x07,0x40,0xF2,0x00,0x05,0x3D,0x60,0x40,0xF2,0x18,0x07,0xC4,0xF2,0x01,0x07,0x40,0xF2,0x80,0x05,0x3D,0x60,0x40,0xF2,0x1C,0x07,0xC4,0xF2,0x01,0x07,0x40,0xF2,0x80,0x05,0x3D,0x60,0x40,0xF2,0x00,0x07,0xC4,0xF2,0x01,0x07,0x50,0x25,0x3D,0x70,0x3A,0xE0,0x40,0xF2,0x38,0x07,0xC4,0xF2,0x01,0x07,0x3D,0x70,0x40,0xF2,0x3C,0x07,0xC4,0xF2,0x01,0x07,0x3E,0x70,0x40,0xF2,0x34,0x07,0xC4,0xF2,0x01,0x07,0x07,0x25,0x3D,0x70,0x40,0xF2,0x00,0x07,0xC4,0xF2,0x01,0x07,0x32,0x25,0x3D,0x70,0x40,0xF2,0x04,0x07,0xC4,0xF2,0x01,0x07,0x97,0xF9,0x00,0x60,0x32,0x25,0x75,0x40,0x05,0xB1,0xF5,0xE7,0x40,0xF2,0x14,0x07,0xC4,0xF2,0x01,0x07,0x40,0xF2,0x00,0x05,0x3D,0x60,0x40,0xF2,0x18,0x07,0xC4,0xF2,0x01,0x07,0x40,0xF2,0x80,0x05,0x3D,0x60,0x40,0xF2,0x1C,0x07,0xC4,0xF2,0x01,0x07,0x40,0xF2,0x80,0x05,0x3D,0x60,0x40,0xF2,0x00,0x07,0xC4,0xF2,0x01,0x07,0x52,0x25,0x3D,0x70,0x00,0xF0,0xCE,0xFA,0x3F,0xB1,0x85,0xF0,0xE8,0x05,0x25,0xB9,0x40,0xF2,0x31,0x01,0x00,0xF0,0xED,0xFA,0x04,0xE0,0x40,0xF2,0x32,0x01,0x00,0xF0,0xE8,0xFA,0xEF,0xE7,0x01,0x46,0x40,0xF2,0x05,0x02,0x00,0xF0,0xAB,0xFA,0x07,0xB9,0xF8,0xE7,0x01,0x78,0x81,0xF0,0x08,0x03,0x03,0xB9,0x1B,0xE0,0x81,0xF0,0x28,0x03,0x03,0xB9,0xB4,0xE0,0x81,0xF0,0x38,0x03,0x03,0xB9,0xDE,0xE0,0x81,0xF0,0x39,0x03,0x03,0xB9,0x44,0xE1,0x81,0xF0,0x3A,0x03,0x03,0xB9,0x7E,0xE1,0x81,0xF0,0x78,0x03,0x03,0xB9,0xB5,0xE1,0x81,0xF0,0x48,0x03,0x03,0xB9,0xC9,0xE1,0x32,0x21,0x00,0xF0,0xC0,0xFA,0xD7,0xE7,0x30,0x21,0x00,0xF0,0xBC,0xFA,0x00,0xF0,0xCA,0xFA,0x4F,0xEA,0x01,0x09,0x31,0x21,0x00,0xF0,0xB5,0xFA,0x01,0x46,0x40,0xF2,0x02,0x22,0x00,0xF0,0x79,0xFA,0x01,0x46,0x40,0xF2,0x00,0x22,0x00,0xF0,0xE4,0xFA,0x90,0xF8,0x00,0x12,0x4F,0xEA,0x01,0x21,0x90,0xF8,0x01,0x22,0x11,0x43,0x69,0x40,0x09,0xB1,0x35,0x21,0xDD,0xE7,0x30,0x21,0x00,0xF0,0x9D,0xFA,0x01,0x46,0x40,0xF2,0x80,0x02,0x4E,0x46,0x00,0xF0,0x22,0xFA,0x00,0xF0,0xD5,0xF9,0x00,0xF0,0x03,0xFA,0xC7,0xB3,0x02,0x31,0x02,0x36,0x00,0xF0,0xCE,0xF9,0x00,0xF0,0xFC,0xF9,0x8F,0xB3,0x02,0x31,0x02,0x36,0x42,0xF2,0x00,0x03,0xC0,0xF2,0x40,0x03,0xB3,0x42,0x02,0xD0,0x01,0x3A,0x02,0xB1,0xE6,0xE7,0x00,0xF0,0x28,0xFA,0x01,0x46,0x40,0xF2,0x80,0x02,0x4E,0x46,0x37,0x68,0x40,0xF2,0x08,0x07,0xC4,0xF2,0x00,0x07,0x3D,0x78,0x00,0x25,0x3D,0x70,0x33,0x68,0x0D,0x68,0x6B,0x40,0xEB,0xB9,0x40,0xF2,0x08,0x07,0xC4,0xF2,0x00,0x07,0x3D,0x78,0x05,0xF0,0x04,0x05,0xC5,0xB9,0x04,0x31,0x04,0x36,0x42,0xF2,0x00,0x03,0xC0,0xF2,0x40,0x03,0xB3,0x42,0x02,0xD0,0x01,0x3A,0x02,0xB1,0xE1,0xE7,0x31,0x21,0x96,0xE7,0x4F,0xF6,0xFF,0x72,0xCF,0xF6,0xFF,0x72,0x4F,0xF6,0xFF,0x73,0xCF,0xF6,0xFF,0x73,0x04,0xE0,0x0A,0x68,0x33,0x68,0x01,0xE0,0x0A,0x68,0x33,0x68,0x34,0x21,0x00,0xF0,0x48,0xFA,0x31,0x0E,0x00,0xF0,0x45,0xFA,0x31,0x0C,0x00,0xF0,0x42,0xFA,0x31,0x0A,0x00,0xF0,0x3F,0xFA,0x31,0x46,0x00,0xF0,0x3C,0xFA,0x11,0x0E,0x00,0xF0,0x39,0xFA,0x11,0x0C,0x00,0xF0,0x36,0xFA,0x11,0x0A,0x00,0xF0,0x33,0xFA,0x11,0x46,0x00,0xF0,0x30,0xFA,0x19,0x0E,0x00,0xF0,0x2D,0xFA,0x19,0x0C,0x00,0xF0,0x2A,0xFA,0x19,0x0A,0x00,0xF0,0x27,0xFA,0x19,0x46,0x00,0xF0,0x24,0xFA,0x34,0x21,0x5F,0xE7,0x30,0x21,0x00,0xF0,0x1F,0xFA,0x00,0xF0,0xC7,0xF9,0x00,0xF0,0x2B,0xFA,0x0B,0x46,0x0F,0x46,0x31,0x21,0x00,0xF0,0x16,0xFA,0x80,0x22,0x39,0x78,0x00,0xF0,0x12,0xFA,0x01,0x37,0x39,0x78,0x00,0xF0,0x0E,0xFA,0x01,0x37,0x39,0x78,0x00,0xF0,0x0A,0xFA,0x01,0x37,0x39,0x78,0x00,0xF0,0x06,0xFA,0x01,0x37,0x01,0x3A,0x02,0xB1,0xEC,0xE7,0x19,0x46,0x40,0xF2,0x00,0x22,0x00,0xF0,0x36,0xFA,0x4F,0xEA,0x15,0x21,0x00,0xF0,0xF9,0xF9,0x29,0x46,0x00,0xF0,0xF6,0xF9,0x31,0x21,0x31,0xE7,0x30,0x21,0x00,0xF0,0xF1,0xF9,0x00,0xF0,0xFF,0xF9,0x4F,0xEA,0x01,0x09,0x00,0xF0,0x76,0xF9,0x40,0xF6,0xA8,0x23,0xC2,0xF2,0x0C,0x03,0x40,0xF2,0xAA,0x05,0x1D,0x60,0x40,0xF2,0x54,0x53,0xC2,0xF2,0x0C,0x03,0x40,0xF2,0x55,0x05,0x1D,0x60,0x40,0xF6,0xA8,0x23,0xC2,0xF2,0x0C,0x03,0x40,0xF2,0x80,0x05,0x1D,0x60,0x40,0xF6,0xA8,0x23,0xC2,0xF2,0x0C,0x03,0x40,0xF2,0xAA,0x05,0x1D,0x60,0x40,0xF2,0x54,0x53,0xC2,0xF2,0x0C,0x03,0x40,0xF2,0x55,0x05,0x1D,0x60,0x40,0xF6,0xA8,0x23,0xC2,0xF2,0x0C,0x03,0x40,0xF2,0x10,0x05,0x1D,0x60,0x4F,0xF6,0xFF,0x75,0x40,0xF2,0x00,0x06,0xC2,0xF2,0x0C,0x06,0x00,0xF0,0x29,0xF9,0x0F,0xB9,0x00,0xF0,0x28,0xF8,0x40,0xF6,0xA8,0x23,0x40,0xF2,0xAA,0x05,0x1D,0x60,0x40,0xF2,0x54,0x53,0x40,0xF2,0x55,0x05,0x1D,0x60,0x40,0xF6,0xA8,0x23,0x40,0xF2,0x80,0x05,0x1D,0x60,0x40,0xF6,0xA8,0x23,0x40,0xF2,0xAA,0x05,0x1D,0x60,0x40,0xF2,0x54,0x53,0x40,0xF2,0x55,0x05,0x1D,0x60,0x40,0xF6,0xA8,0x23,0x40,0xF2,0x10,0x05,0x1D,0x60,0x4F,0xF6,0xFF,0x75,0x4E,0x46,0x00,0xF0,0x03,0xF9,0x1F,0xB1,0x00,0xF0,0x3A,0xF9,0x31,0x21,0xCB,0xE6,0x00,0xF0,0x36,0xF9,0x34,0x21,0xC7,0xE6,0x30,0x21,0x00,0xF0,0x87,0xF9,0x00,0xF0,0x2F,0xF9,0x42,0xF2,0x00,0x03,0xC0,0xF2,0x40,0x03,0x1D,0x68,0x4F,0xF2,0x00,0x23,0xC2,0xF2,0x03,0x03,0x1D,0x60,0x40,0xF2,0x00,0x13,0xC4,0xF2,0x00,0x03,0x1D,0x68,0x4F,0xF2,0x04,0x23,0xC2,0xF2,0x03,0x03,0x1D,0x60,0x4F,0xF2,0x00,0x23,0xC2,0xF2,0x03,0x03,0x19,0x78,0x00,0xF0,0x6A,0xF9,0x01,0x33,0x19,0x78,0x00,0xF0,0x66,0xF9,0x01,0x33,0x19,0x78,0x00,0xF0,0x62,0xF9,0x01,0x33,0x19,0x78,0x00,0xF0,0x5E,0xF9,0x01,0x33,0x19,0x78,0x00,0xF0,0x5A,0xF9,0x01,0x33,0x19,0x78,0x00,0xF0,0x56,0xF9,0x01,0x33,0x19,0x78,0x00,0xF0,0x52,0xF9,0x01,0x33,0x19,0x78,0x00,0xF0,0x4E,0xF9,0x31,0x21,0x89,0xE6,0x30,0x21,0x00,0xF0,0x49,0xF9,0x00,0xF0,0x57,0xF9,0x01,0x46,0x01,0x31,0x42,0xF2,0x00,0x06,0xC0,0xF2,0x40,0x06,0x00,0xF0,0xCA,0xF8,0x00,0xF0,0x7D,0xF8,0x00,0xF0,0xAB,0xF8,0x27,0xB3,0x02,0x31,0x02,0x36,0x00,0xF0,0x76,0xF8,0x00,0xF0,0xA4,0xF8,0xEF,0xB1,0x00,0xF0,0xDB,0xF8,0x01,0x46,0x01,0x31,0x42,0xF2,0x00,0x06,0xC0,0xF2,0x40,0x06,0x37,0x68,0x40,0xF2,0x08,0x07,0xC4,0xF2,0x00,0x07,0x3D,0x78,0x00,0x25,0x3D,0x70,0x33,0x68,0x0D,0x68,0x6B,0x40,0x4B,0xB9,0x40,0xF2,0x08,0x07,0xC4,0xF2,0x00,0x07,0x3D,0x78,0x05,0xF0,0x04,0x05,0x0D,0xB9,0x31,0x21,0x52,0xE6,0x00,0xF0,0xBD,0xF8,0x34,0x21,0x4E,0xE6,0x30,0x21,0x00,0xF0,0x0E,0xF9,0x31,0x21,0x00,0xF0,0x0B,0xF9,0x48,0xF2,0x05,0x0B,0xC4,0xF2,0x03,0x0B,0x9B,0xF8,0x00,0xC0,0x1C,0xF0,0x01,0x0C,0xF6,0xD0,0x40,0xF2,0x04,0x01,0xC0,0xF2,0x00,0x01,0x4E,0xF6,0x0C,0x53,0xCE,0xF2,0x00,0x03,0x19,0x60,0x30,0x21,0x00,0xF0,0xF6,0xF8,0x01,0x46,0x05,0x31,0x40,0xF2,0x04,0x02,0x00,0xF0,0xB9,0xF8,0x00,0xF0,0x0C,0xF9,0x00,0xF0,0x96,0xF8,0x4F,0xF6,0xFF,0x72,0xCF,0xF6,0xFF,0x72,0x1D,0x68,0x2E,0x46,0x55,0x40,0x35,0xB9,0x04,0x33,0x1F,0x46,0x8F,0x42,0x00,0xD2,0xF6,0xE7,0x31,0x21,0x1A,0xE6,0x34,0x21,0x00,0xF0,0xDA,0xF8,0x19,0x0E,0x00,0xF0,0xD7,0xF8,0x19,0x0C,0x00,0xF0,0xD4,0xF8,0x19,0x0A,0x00,0xF0,0xD1,0xF8,0x19,0x46,0x00,0xF0,0xCE,0xF8,0x31,0x0E,0x00,0xF0,0xCB,0xF8,0x31,0x0C,0x00,0xF0,0xC8,0xF8,0x31,0x0A,0x00,0xF0,0xC5,0xF8,0x31,0x46,0x00,0xF0,0xC2,0xF8,0x34,0x21,0xFD,0xE5,0x40,0xF2,0x00,0x03,0xC2,0xF2,0x00,0x03,0x33,0x40,0xBB,0xB1,0x40,0xF2,0xAA,0x05,0x40,0xF6,0xA8,0x23,0xC2,0xF2,0x0C,0x03,0x1D,0x60,0x40,0xF2,0x54,0x53,0xC2,0xF2,0x0C,0x03,0x40,0xF2,0x55,0x05,0x1D,0x60,0x40,0xF6,0xA8,0x23,0xC2,0xF2,0x0C,0x03,0x40,0xF2,0xA0,0x05,0x1D,0x60,0x0D,0x88,0x35,0x80,0x10,0xE0,0x40,0xF2,0xAA,0x05,0x40,0xF6,0xA8,0x23,0x1D,0x60,0x40,0xF2,0x54,0x53,0x40,0xF2,0x55,0x05,0x1D,0x60,0x40,0xF6,0xA8,0x23,0x40,0xF2,0xA0,0x05,0x1D,0x60,0x0D,0x88,0x35,0x80,0xF7,0x46,0x33,0x88,0x33,0x88,0x4F,0xEA,0x03,0x0A,0x40,0xF2,0x80,0x07,0x3B,0x40,0x2F,0x40,0x5F,0x40,0x77,0xB1,0x53,0x46,0x40,0xF2,0x20,0x07,0x1F,0x40,0x07,0xB9,0xF0,0xE7,0x33,0x88,0x40,0xF2,0x80,0x07,0x3B,0x40,0x2F,0x40,0x5F,0x40,0x0F,0xB1,0x00,0x27,0xF7,0x46,0x01,0x27,0xF7,0x46,0x40,0xF2,0x08,0x07,0xC4,0xF2,0x00,0x07,0x3D,0x78,0x05,0xF0,0x01,0x05,0x05,0xB9,0xF6,0xE7,0x40,0xF2,0x00,0x07,0xC4,0xF2,0x00,0x07,0x01,0x25,0x3D,0x70,0x40,0xF2,0x08,0x07,0xC2,0xF2,0x0E,0x07,0x3D,0x78,0x05,0xF0,0x01,0x05,0x05,0xB9,0xF6,0xE7,0x40,0xF2,0x00,0x07,0xC2,0xF2,0x0E,0x07,0x00,0x25,0x3D,0x70,0xF7,0x46,0x40,0xF2,0x08,0x07,0xC4,0xF2,0x00,0x07,0x3D,0x78,0x05,0xF0,0x01,0x05,0x05,0xB9,0xF6,0xE7,0x40,0xF2,0x00,0x07,0xC4,0xF2,0x00,0x07,0x02,0x25,0x3D,0x70,0x40,0xF2,0x08,0x07,0xC2,0xF2,0x0E,0x07,0x3D,0x78,0x05,0xF0,0x01,0x05,0x05,0xB9,0xF6,0xE7,0x40,0xF2,0x00,0x07,0xC2,0xF2,0x0E,0x07,0x01,0x25,0x3D,0x70,0xF7,0x46,0x74,0x46,0x00,0xF0,0x0D,0xF8,0x37,0xB1,0x0D,0x70,0x01,0x31,0x01,0x3A,0x02,0xB1,0xF7,0xE7,0x01,0x27,0xA7,0x46,0x32,0x21,0x00,0xF0,0x29,0xF8,0x00,0x27,0xA7,0x46,0x48,0xF2,0x05,0x03,0xC4,0xF2,0x03,0x03,0x93,0xF8,0x00,0x70,0x07,0xF0,0x38,0x07,0x8F,0xB9,0x48,0xF2,0x05,0x03,0xC4,0xF2,0x03,0x03,0x93,0xF8,0x00,0x70,0x07,0xF0,0x04,0x07,0x07,0xB9,0xEC,0xE7,0x48,0xF2,0x08,0x03,0xC4,0xF2,0x03,0x03,0x93,0xF8,0x00,0x50,0x01,0x27,0xF7,0x46,0x48,0xF2,0x05,0x03,0xC4,0xF2,0x03,0x03,0x93,0xF8,0x00,0x70,0x47,0xF0,0x80,0x07,0x1F,0x70,0x4F,0xF0,0x00,0x07,0xF7,0x46,0x48,0xF2,0x05,0x0B,0xC4,0xF2,0x03,0x0B,0x9B,0xF8,0x00,0xC0,0x1C,0xF0,0x01,0x0C,0xF6,0xD0,0x48,0xF2,0x08,0x0C,0xC4,0xF2,0x03,0x0C,0x8C,0xF8,0x00,0x10,0xF7,0x46,0x01,0x79,0x4F,0xEA,0x01,0x61,0xC6,0x78,0x4F,0xEA,0x06,0x46,0x31,0x43,0x86,0x78,0x4F,0xEA,0x06,0x26,0x31,0x43,0x46,0x78,0x31,0x43,0xF7,0x46,0x01,0x7A,0x4F,0xEA,0x01,0x61,0xC6,0x79,0x4F,0xEA,0x06,0x46,0x31,0x43,0x86,0x79,0x4F,0xEA,0x06,0x26,0x31,0x43,0x46,0x79,0x31,0x43,0x03,0x79,0x4F,0xEA,0x03,0x63,0xC6,0x78,0x4F,0xEA,0x06,0x46,0x33,0x43,0x86,0x78,0x4F,0xEA,0x06,0x26,0x33,0x43,0x46,0x78,0x33,0x43,0xF7,0x46,0x40,0xF2,0x00,0x05,0x40,0xF2,0x00,0x03,0xC1,0xF2,0x21,0x03,0x0F,0x78,0x01,0x31,0x3F,0x06,0x6F,0x40,0x7F,0x00,0x00,0xD3,0x5F,0x40,0x7F,0x00,0x00,0xD3,0x5F,0x40,0x7F,0x00,0x00,0xD3,0x5F,0x40,0x7F,0x00,0x00,0xD3,0x5F,0x40,0x7F,0x00,0x00,0xD3,0x5F,0x40,0x7F,0x00,0x00,0xD3,0x5F,0x40,0x7F,0x00,0x00,0xD3,0x5F,0x40,0x7F,0x00,0x00,0xD3,0x5F,0x40,0x3D,0x46,0x01,0x3A,0x02,0xB1,0xDF,0xE7,0x2D,0x0C,0xF7,0x46,0x00,0x00,0x4D,0x42,0x39,0x42,0x35,0x36,0x34,0x4B,0x20,0x52,0x65,0x76,0x31,0x2E,0x31,0x39,0xB3};
static UCHAR jump_to_ram[]={0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0};
static UCHAR erase_cr_data_read[]={0x39, 0x00, 0x00, 0x00, 0x00};
static UCHAR cr_trimming_mirror_data[]={0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,};
static UCHAR chip_erase[]={0x38, 0xFF, 0xFF, 0x03, 0x00};
static UCHAR blank_check_0[]={0x48, 0x00, 0x00, 0x00, 0x00};
static UCHAR blank_check_1[]={0xFF, 0xFF, 0x03, 0x00};

static long   _ExeSize=0;
static UCHAR *_ExeBuf=NULL;

//--- cond_comm_init -------------------
int cond_comm_init(void)
{
	FILE		*file;
	UINT32		mem_ctr;
	int			tio, ret, i, ok;
	int			condNo;
	char		str[64];

	memset(&_FileVersion, 0, sizeof(_FileVersion));	
	memset(_COMM, 0, sizeof(_COMM));
	memset(_DnlState, 0, sizeof(_DnlState));
	memset(_DnlError, 0, sizeof(_DnlError));
	memset(_DnlProgress, 0, sizeof(_DnlProgress));

	if (!nios_loaded()) return REPLY_ERROR;
		
	//--- read from bin file ----------------
	file = fopen(PATH_BIN_HEAD FILENAME_HEAD_COND, "rb");
	if (!file) return Error(ERR_CONT, 0, "read file error >>%s<<", PATH_BIN_HEAD FILENAME_HEAD_COND);
	fseek(file, 0, SEEK_END);
	_ExeSize = ftell(file);
	fseek(file, 0, SEEK_SET);

	_ExeBuf = (UCHAR*)malloc(_ExeSize);
	if (_ExeBuf == NULL) return Error(ERR_ABORT, 0, "Could not allocate conditioner exe memory");
	fread(_ExeBuf, 1, _ExeSize, file);
	fseek(file, _ExeSize-sizeof(str), SEEK_SET);
	fread(str, 1, sizeof(str), file);
	fclose(file);

	//---  get file version ---------------
	for (i=0; i<sizeof(str); i++)
	{
		if (sscanf(&str[i], "Version=%d.%d.%d.%d", &_FileVersion.major, &_FileVersion.minor, &_FileVersion.revision, &_FileVersion.build)==4)
			break;			
	}

	term_printf("File Version: %d.%d.%d.%d\n",  _FileVersion.major, _FileVersion.minor, _FileVersion.revision, _FileVersion.build);
	term_flush();
	_CondStartup = 0;
	_CondProgram = FALSE;
	_CondRunning = TRUE;
	for (condNo=0; condNo<MAX_HEADS_BOARD;  condNo++)
		rx_thread_start(_uart_thread, (void*)condNo, 0, "Conditioner UART");
}

//--- cond_comm_end -------------------------
int  cond_comm_end(void)
{
	int condNo;
	_CondRunning = FALSE;
	for (condNo=0; condNo<MAX_HEADS_BOARD;  condNo++)
	{
		if (_COMM[condNo]) close(_COMM[condNo]);
	}
}

//--- cond_comm_state -----------------------------
char *cond_comm_state(int condNo, char *str)
{
	char err[4];
	if (_DnlError[condNo]) strcpy(err, "E ");
	else strcpy(err, "");
	
	switch (_DnlState[condNo])
	{
    case dnl_start:				sprintf(str, "%sstart", err);		return str;
    case dnl_prepare:			sprintf(str, "%sprepare", err);		return str;
    case dnl_reset:				sprintf(str, "%sreset", err);		return str;
    case dnl_send_ram_kernel:	sprintf(str, "%sld-kernel", err);	return str;
    case dnl_start_ram_kernel:	sprintf(str, "%sstart-kernel", err);return str;
    case dnl_read_flash:		sprintf(str, "%sread", err);		return str;
    case dnl_chip_erase:		sprintf(str, "%serase", err);		return str;
    case dnl_blank_check:		sprintf(str, "%sblank-check", err);	return str;
    case dnl_write_binary:		sprintf(str, "%sprogram", err);		return str;
    case dnl_mcu_reset2:		sprintf(str, "%srestart-app", err);	return str;
    case dnl_done:				sprintf(str, "%sDONE", err);		return str;	
    case dnl_ok:				sprintf(str, "%sOK", err);			return str;			
	default:					strcpy(str,  "undef");				return str;
	}
}

//--- cond_comm_version_ok ----------------------------------
int  cond_comm_version_ok(int condNo)
{
	int ok=!memcmp(&RX_CondStat[condNo].version, &_FileVersion, sizeof(SVersion));
	return ok;
}

//--- _uart_thread ---------------------------------------------
static void *_uart_thread(void *ppar)
{
	int		condNo = (int)ppar;
	char	uart_name[32];
	int		comm, i;

	sprintf(uart_name, "/dev/ttyAL%d", condNo);
	
	//--- open interface ----------------------------
	comm = open(uart_name, O_RDWR);// | O_NOCTTY | O_SYNC);
	if (comm == -1) 
	{
		char str[128];
		err_system_error(errno, str, sizeof(str));
		printf("Comm %s Error %d: %s\n", uart_name, errno, str);
		Error(ERR_ABORT, 0, "Cound not open serial interface to conditioner[%d].", condNo);
		return NULL;
	}
	
	//--- read configuration -----------------	
	cond_restart_app(condNo);
	rx_sleep(200);
	if (_cond_receive(comm, condNo, 1) == REPLY_ERROR || !cond_comm_version_ok(condNo) )
	{
		for (i=0; i<5; i++)
		{
			_program_exe(comm, condNo);			
			if (_DnlState[condNo] == dnl_done) break;
			rx_sleep(500);
		}
		if (_DnlError[condNo]) RX_CondStat[condNo].error |= COND_ERR_download;
	}
	else _DnlState[condNo] = dnl_ok; 

	_cond_receive(comm, condNo, 0);
	return NULL;
}

//--- _cond_receive -------------------------------
static int _cond_receive(int comm, int condNo, int cnt)
{
	struct timeval timeout;
	fd_set readSet;
	int len, i;
	
	_uart_set_baud(comm, B115200, 256);
	comm_init(condNo);
	_COMM[condNo] = comm;

	// check for timeout
	timeout.tv_sec  = 1;
	timeout.tv_usec = 0;
	
	while (_CondRunning)
	{
		UCHAR data[256];

		FD_ZERO(&readSet);
		FD_SET(comm, &readSet);
		if (select(comm + 1, &readSet, NULL, NULL, &timeout) == 0) 
		{
			if (cnt) 
				return REPLY_ERROR;
			else if (RX_CondStat[condNo].info.connected) 
			{
				RX_CondStat[condNo].info.connected = FALSE;
				RX_CondStat[condNo].error |= COND_ERR_connection_lost;
			}
		}

		len = read(comm, &data, sizeof(data));
		for (i=0; i<len; i++)
		{			
			if (comm_received(condNo, data[i]))
			{				
				int length;
				UCHAR buf[256];
				if (comm_get_data(condNo, (UCHAR*)&buf, sizeof(buf), &length))
				{
					cond_handle_status(condNo, (SConditionerStat_mcu*)&buf, length);
					if (cnt && (--cnt == 0)) 
					{
						_COMM[condNo] = 0;
						return REPLY_OK;
					}
					// check for timeout
					timeout.tv_sec  = 1;
					timeout.tv_usec = 0;
				}		
			}
		}
	}
	return REPLY_ERROR;
}

//--- _uart_load_thread ------------------------------------
static int   _program_exe(int comm, int condNo)
{	
	SFlashData flashData;
	int state = 0;
	
	_uart_set_baud(comm, B9600, 0);
	_DnlError[condNo] = FALSE;
	_DnlState[condNo] = dnl_start;
	_DnlError[condNo] |= cond_restart_loader(condNo);
	if (!_DnlError[condNo])
	{
		_DnlError[condNo] |= _send_ram_kernel(comm, condNo); 		
	}
	if (!_DnlError[condNo])
	{		
		state = 1;
		_uart_set_baud(comm, B115200, 0);
		rx_sleep(250);
		
		_DnlError[condNo] |= _send(comm, condNo, _0xe8, sizeof(_0xe8), 0x31, 100);  
	}
	if (!_DnlError[condNo])
	{
		state = 2;
		_DnlError[condNo] |= _read_user_flash(comm, condNo, &flashData);
	}
	if (!_DnlError[condNo])
	{
		state = 3;			
		_DnlError[condNo] |= _erase_and_check(comm, condNo);		
	}
	
	if (!_DnlError[condNo])
	{
		state = 4;
		_DnlError[condNo] |= _write_user_flash(comm, condNo, &flashData);			
	}
	
	if (!_DnlError[condNo])
	{
		state = 5;
		_DnlError[condNo] |= _program_flash(comm, condNo, _ExeBuf, _ExeSize);			
	}		
	
	if (!_DnlError[condNo]) _DnlState[condNo] = dnl_mcu_reset2;
	
	if (!_DnlError[condNo]) 
	{
		cond_restart_app(condNo);
		_DnlState[condNo] = dnl_done;
	}
}

//--- _send_ram_kernel -----------------------
static int _send_ram_kernel(int comm, int condNo)
{	
	rx_sleep(100);
	_DnlState[condNo] = dnl_reset;	
	if (_send(comm, condNo, _0x18,			    sizeof(_0x18),				0x11,  100)) return Error(ERR_ABORT, 0, "Conditioner[%d].Timeout Restart 1",		condNo);
	_DnlState[condNo] = dnl_send_ram_kernel;
	if (_send(comm, condNo, ram_kernel_prepare, sizeof(ram_kernel_prepare),	0x01, 2000)) return Error(ERR_ABORT, 0, "Conditioner[%d].Timeout Prepare Kernel",	condNo);			
	if (_send(comm, condNo, ram_kernel,		    sizeof(ram_kernel),			0x01, 5000)) return Error(ERR_ABORT, 0, "Conditioner[%d].Timeout Load Kernel",		condNo);
//	rx_sleep(100);
	_DnlState[condNo] = dnl_start_ram_kernel;
	if (_send(comm, condNo, _0x18,             sizeof(_0x18),				0x11,  100)) return Error(ERR_ABORT, 0, "Conditioner[%d].Timeout Start Kernel",		condNo);				
	if (_send(comm, condNo, jump_to_ram,		sizeof(jump_to_ram),		0x31, 1000)) return Error(ERR_ABORT, 0, "Conditioner[%d].Timeout Jump To Ram",		condNo);
	return REPLY_OK;
}

//--- _read_user_flash --------------------------------
static int _read_user_flash(int comm, int condNo, SFlashData *data)
{
	SFlashCmd  cmd = {.cmd=0x28, .addr=CONDITIONER_FLASH_USER_ADDR };
	if (_send(comm, condNo, (UCHAR*)&cmd, sizeof(cmd), 0x31, 500)) return REPLY_ERROR;
	if (_read_block(comm, condNo, 200, (UCHAR*)data, sizeof(SFlashData))) return Error(ERR_ABORT, 0, "Conditioner[%d].Timeout Reading Uesr Flash",		condNo);
	return REPLY_OK;
}

//--- _write_user_flash -------------------------------
static int _write_user_flash(int comm, int condNo, SFlashData *data)
{
	SFlashCmd  cmd = {.cmd=0x08, .addr=CONDITIONER_FLASH_USER_ADDR };
	if (_send(comm, condNo, (UCHAR*)&cmd, sizeof(cmd), 0x31, 200)) return REPLY_ERROR;
	if (_send(comm, condNo, (UCHAR*)data, sizeof(SFlashData), 0x31, 500)) return REPLY_ERROR;
	return REPLY_OK;
}

//--- _erase_and_check --------------------------------
static int _erase_and_check(int comm, int condNo)
{
	_DnlState[condNo] = dnl_chip_erase;
	if (_send(comm, condNo, chip_erase,    sizeof(chip_erase),    0x31, 1000)) return REPLY_ERROR;
	rx_sleep(5500);
	_DnlState[condNo] = dnl_blank_check;
	if (_send(comm, condNo, blank_check_0, sizeof(blank_check_0), 0x31, 5000)) return REPLY_ERROR;
	if (_send(comm, condNo, blank_check_1, sizeof(blank_check_1), 0x31, 5000)) return REPLY_ERROR;
	return REPLY_OK;
}

//--- _program_flash ----------------------------------------------
static int _program_flash(int comm, int condNo, UCHAR *buf, int size)
{
	SFlashCmd		cmd;
	unsigned short	crc;
	SFlashData		data;

	_DnlState[condNo] = dnl_write_binary;
	cmd.cmd  = 0x08; // write command
	for(cmd.addr=0; cmd.addr<size; cmd.addr+=FLASH_BLK_SIZE)
	{
		memset(&data, 0x00, sizeof(data));
		if(size-cmd.addr > FLASH_BLK_SIZE)
			memcpy(data.data, &buf[cmd.addr], FLASH_BLK_SIZE);
		else
			memcpy(data.data, &buf[cmd.addr], size-cmd.addr);
		crc=crc_calc((char*)data.data, FLASH_BLK_SIZE);
		data.crc_low  = (crc&0xff);
		data.crc_high = (crc&0xff00)>>8;

		if (_send(comm, condNo, (UCHAR*)&cmd,  sizeof(cmd),  0x31, 200)) return REPLY_ERROR;
		if (_send(comm, condNo, (UCHAR*)&data, sizeof(data), 0x31, 500)) return REPLY_ERROR;
	}
	return REPLY_OK;
}

//--- cond_send ----------------------------------
void cond_send(int condNo, SConditionerCfg_mcu *pcfg)
{	
	UCHAR buf[1024];
	int len;
	if (_COMM[condNo] > 0)
	{
		if (comm_encode(pcfg, sizeof(SConditionerCfg_mcu), buf, sizeof(buf), &len))
		{
			write(_COMM[condNo], buf, len);		
		}		
	}
}

//--- _uart_set_baud --------------------
static void _uart_set_baud(int comm, int baud, int blksize)
{
	struct termios options;
		
	memset(&options, 0, sizeof(options));

	options.c_iflag = IGNBRK|IGNPAR;
	options.c_lflag = NOFLSH;
	options.c_cflag = CS8|CREAD|CLOCAL|baud;
	options.c_cc[VMIN] = blksize; 
	cfsetispeed(&options, baud);
	cfsetospeed(&options, baud);

	tcsetattr(comm, TCSAFLUSH, &options);
}

//--- _send -------------------------------
static int _send(int comm, int conNo, UCHAR *data, int len, UCHAR reply, int tio)
{
	UCHAR recv;
	int i;
	struct timeval timeout;
	fd_set readSet;
			
	for (i=0; i<5; i++)
	{
		recv=0;
		timeout.tv_sec  = tio/1000;
		timeout.tv_usec = 1000*(tio%1000);
		write(comm, data, len);
	read:
		FD_ZERO(&readSet);
		FD_SET(comm, &readSet);
		if (select(comm + 1, &readSet, NULL, NULL, &timeout) == 0) 
		{
			if (tio == 100) continue;
			return REPLY_ERROR;
		};
		read(comm, &recv, 1);
		if (recv==reply) return REPLY_OK;
		switch (recv)
		{
		case 0x02: return REPLY_ERROR;	// error ?
		case 0x30: goto read;
		case 0x31:
			TrPrintf(TRUE, "cond[%d]: OK\n", conNo);
			break;

		case 0x32:
			Error(ERR_ABORT, 0, "Downloading Conditioner[%d]: ERROR blank check", conNo);
			return REPLY_ERROR;

		case 0x34:
			Error(ERR_ABORT, 0, "Downloading Conditioner[%d]: ERROR write", conNo);
			return REPLY_ERROR;

		case 0x35:
			Error(ERR_ABORT, 0, "Downloading Conditioner[%d]: ERROR CRC", conNo);
			return REPLY_ERROR;
		}		
	}
	return REPLY_ERROR;
}

//--- _read_block --------------------------------------
static int _read_block(int comm, int condNo, int tio, UCHAR *buf, int size)
{
	int pos, len;
	struct timeval timeout;
	fd_set readSet;
	timeout.tv_sec  = tio/1000;
	timeout.tv_usec = 1000*(tio%1000);
	pos=0;
	while (pos<size)
	{		
		FD_ZERO(&readSet);
		FD_SET(comm, &readSet);

		if (select(comm + 1, &readSet, NULL, NULL, &timeout) ) 
		{
			len=read(comm, &buf[pos], size-pos);
			pos+=len;			
		}		
	}
	return REPLY_OK;
}